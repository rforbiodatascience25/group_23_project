---
title: "clean raw data"
format: 
  html:
    self-contained: true
editor: visual
---

# Load Libraries

```{r}
#| message: false
library(here)
library(tidyverse)
library(ggplot2)
library(readr)
```

# Load Data

```{r}
folder <- here("data", "_raw")
```

```{r}
mutation <- read_delim(file.path(folder, "tmb_mskcc_2018/data_mutations.txt"), delim = "\t", col_names = TRUE)

raw_data_sv <- read_delim(file.path(folder, "tmb_mskcc_2018/data_sv.txt"), delim = "\t")
```

# Data cleaning of mutations

## NA handling

We begin by looking at all the columns with all nas in it.

```{r}
all_na_columns <- mutation |> 
  
  summarise(across(.cols = everything(), 
                   .fns = ~ all(is.na(.x)))) |> 
  
  pivot_longer(cols = everything(), 
               names_to = "column_name", 
               values_to = "is_all_na") |> 
  
  filter(is_all_na == TRUE) |> 
  
  pull(column_name)

print("Columns containing only NA values:")
print(all_na_columns)
```

```{r}
sprintf("There are %i empty columns.",length(all_na_columns))
```

We drop all these columns:

```{r}
data_mutation_without_nas <- mutation |> 
  select(-all_of(all_na_columns))

# Verify the result by comparing the number of columns
print(paste("Original columns:", ncol(mutation)))
print(paste("New columns:", ncol(data_mutation_without_nas)))
  
```

The new data set looks like this

```{r}
data_mutation_without_nas |> 
  slice_sample(n=5)
```

```{r}
print("The resulting columns are:")
colnames(data_mutation_without_nas)
```

However, there are still columns with some NAs in it -\> what to do about it?

```{r}
na_containing_columns <- data_mutation_without_nas |> 
  summarise(across(
    everything(),
    .fns = ~ sum(is.na(.x))
  )) |> 
  pivot_longer(
    everything(),
    names_to = "column_name",
    values_to = "na_count"
  ) |> 
  filter(na_count > 0)

na_containing_columns
```

We see that dbSNP_RS is almost only NAs (20026 over 20563), thus we can drop this column. Apart from that, the only variables that have a significant number of NAs are ALLELE_NUM ans IS_NEW. It seems that ALLELE_NUM is an internal indicator, so we wouldn"t use it, therefor we"ll also drop it.

```{r}
data_mutation_without_nas <- data_mutation_without_nas |> 
  select(-c("dbSNP_RS", "ALLELE_NUM"))
```

For IS_NEW, we"ll check if NA corresponds to a not-new allele, in this case we would just infere the NAs to be null or 0.

```{r}
is_new_values <- data_mutation_without_nas |>
  summarize(unique_is_new = unique(IS_NEW))

print("The values in the IS_NEW column are:")
is_new_values 
```

So indeed the NAs here means that it"s not new. So we will replace NAs by NOTNEW, and then input NOTNEW by 0 and NEWRECORD by 1 (hotspot encoding is easier to use in code).

```{r}
data_mutation_without_nas <- data_mutation_without_nas |> 
  mutate(IS_NEW = case_when(
    is.na(IS_NEW) ~ 0,
    IS_NEW == "NEWRECORD" ~ 1
  ))
```

For the rest of the column with NAs, we will keep all their rows and just using na.rm = TRUE when using the columns (we can do inference bc they"re not statistical or calculated variable).

We will search all columns with constant value to also drop them as we already know their values.

```{r}
is_single_value <- function(x) {
  n_distinct(x) == 1
}

single_value_columns <- data_mutation_without_nas |> 
  summarise(across(everything(), is_single_value)) |> 
  pivot_longer(everything(), names_to = "column_name", values_to = "is_single_value") |> 
  filter(is_single_value == TRUE) |> 
  pull(column_name)
  
single_value_columns
```

So we can drop all these columns knowing their constant values.

```{r}
data_mutation_without_nas <- data_mutation_without_nas |> 
  select(-c("Center","NCBI_Build","Strand","Validation_Status","Hotspot","Score"))
```

```{r}
is_factor <-  function(x){
  is_char <- is.character(x)
  bool <- n_distinct(x)<=40
  
  return(is_char & bool)
}

column_to_factor <- data_mutation_without_nas |> 
  select(where(is_factor)) |> 
  names()

print("The column to factor are:")
column_to_factor
```

Lot of NAs in ALLELE_NUM and IS_NEW, how to deal with?

```{r}
data_mutation_without_nas <- data_mutation_without_nas |> 
  mutate(across(all_of(column_to_factor), factor))
```

We see that for some rows there are several consequences -\> we split them into several columns. First lets check how many na is there in it.

```{r}
consequence_na <- data_mutation_without_nas |> 
  summarise(consequence_na = sum(is.na(Consequence))) |> 
  pull(consequence_na)

sprintf("There is %i nas in the consequence column.", as.integer(consequence_na))
```

```{r}
data_mutation_without_nas <-  data_mutation_without_nas |> 
  mutate(n_consequences = str_count(Consequence,",")+1)
```

```{r}
max_consequences <- data_mutation_without_nas$n_consequences |> 
  max()
sprintf("The max number of consequences for one row is %.4f",max_consequences)
```

```{r}
data_mutation_without_nas_wide <- data_mutation_without_nas |> 
    separate(col = "Consequence",
           into = str_c("consequence_", 1:max_consequences),
           sep = ",",
           remove = TRUE)
```

```{r}
data_mutation_without_nas_long <- data_mutation_without_nas_wide |> 
  pivot_longer(
    cols = contains("consequence_"),
    names_to = NULL,
    values_to = "consequence"
    ) |> 
  drop_na("consequence") |> 
  mutate(
    consequence = as.factor(consequence),
    patient_id = str_extract(Tumor_Sample_Barcode, "^P-\\d{7}")
  ) |> 
  relocate(c(patient_id,Tumor_Sample_Barcode),
           .before = Entrez_Gene_Id)

data_mutation_without_nas_long |> 
  sample_n(5)
```

## Export the cleaned data

```{r}
if(!dir.exists(here("data"))) dir.create(here("data"))

data_mutation_without_nas_long |>
  write_tsv(file = here("data","data_mutation_cleaned.tsv"))
```

# Structural Variants Cleaning and exporting

Discarding two columns that had a constant value: SOMATIC for SV_Status and GRCh37 for NCBI_Build.

```{r}

cleaned_sv <- raw_data_sv |> 
  select(-SV_Status, -NCBI_Build)

```

The file"s dimensions are inconsistent with the other files, and the Sample_ID column is not a unique identifier, so it cannot serve as a primary key for subsequent joins. We will export this cleaned file and handle the various merging operations later in the analysis, ensuring the appropriate joining method is applied based on the expected output.

```{r}
cleaned_sv |>
  write_tsv(file = here("data","sv_cleaned.tsv"))
```
